(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{73:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return b})),a.d(t,"metadata",(function(){return i})),a.d(t,"toc",(function(){return o})),a.d(t,"default",(function(){return s}));var n=a(3),r=a(7),l=(a(0),a(88)),b={id:"storage",title:"Storage API Reference",hide_title:!0,sidebar_label:"Storage API",slug:"/storage/"},i={unversionedId:"storage",id:"storage",isDocsHomePage:!1,title:"Storage API Reference",description:"StorageWrapper",source:"@site/docs/storage.md",slug:"/storage/",permalink:"/docs/storage/",version:"current",sidebar_label:"Storage API",sidebar:"docs",previous:{title:"Configuration",permalink:"/docs/configuration/"}},o=[{value:"<code>hasItem</code>",id:"hasitem",children:[]},{value:"<code>getItem</code>",id:"getitem",children:[]},{value:"<code>setItem</code>",id:"setitem",children:[]},{value:"<code>removeItem</code>",id:"removeitem",children:[]},{value:"<code>mergeItem</code>",id:"mergeitem",children:[]},{value:"<code>multiGet</code>",id:"multiget",children:[]},{value:"<code>multiSet</code>",id:"multiset",children:[]},{value:"<code>multiRemove</code>",id:"multiremove",children:[]},{value:"<code>multiMerge</code>",id:"multimerge",children:[]},{value:"<code>clear</code>",id:"clear",children:[]},{value:"<code>keys</code>",id:"keys",children:[]}],c={toc:o};function s(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h1",{id:"storagewrapper"},"StorageWrapper"),Object(l.b)("p",null,"The storage wrapper is the main class with which the user interacts in this library."),Object(l.b)("h2",{id:"hasitem"},Object(l.b)("inlineCode",{parentName:"h2"},"hasItem")),Object(l.b)("p",null,"Checks whether a given key exists in storage. This method is ",Object(l.b)("em",{parentName:"p"},"synchroneous"),"."),Object(l.b)("br",null),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.hasItem(key: string): boolean\n")),Object(l.b)("h2",{id:"getitem"},Object(l.b)("inlineCode",{parentName:"h2"},"getItem")),Object(l.b)("p",null,"Retrieves a value from storage. The value is automatically deserialized into a javascript value, so you do not need to call ",Object(l.b)("inlineCode",{parentName:"p"},"JSON.parse()"),"."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.getItem<T>(\n    key: string,\n    options?: {\n        fallback?: T\n        allowNull?: boolean\n    },\n    callback?: (error: Error | null, result?: T | null) => void\n): Promise<T | null>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"key"),": The key of the value being retrieved (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"options"),": The second parameter is an optional object that has two optional keys:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"fallback"),": By default ",Object(l.b)("inlineCode",{parentName:"li"},"getItem"),"returns ",Object(l.b)("inlineCode",{parentName:"li"},"null")," when no value is found for the given key. You can customize this by passing an optional fallback value as part of the options object."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"allowNull"),": By default ",Object(l.b)("inlineCode",{parentName:"li"},"getItem")," will not throw an error if a value is not found for the given key and no fallback is provided. To change this, you can set ",Object(l.b)("inlineCode",{parentName:"li"},"allowNull")," to ",Object(l.b)("inlineCode",{parentName:"li"},"true"),", which will cause the function to throw a ",Object(l.b)("inlineCode",{parentName:"li"},"StorageError")," if no value is found.")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"callback"),": Node style callback."),Object(l.b)("br",null),Object(l.b)("h2",{id:"setitem"},Object(l.b)("inlineCode",{parentName:"h2"},"setItem")),Object(l.b)("p",null,"Sets a value in storage. The value is automatically serialized, so you do not need to call ",Object(l.b)("inlineCode",{parentName:"p"},"JSON.stringify()"),"."),Object(l.b)("p",null,"::: note If you want to serialized functions or classes with methods you will need to serialized them before calling setItem, because these cannot be serialized by the library.\n:::"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.setItem<T>(\n    key: string,\n    value: () => T | T,\n    maxAge?: number | [number, TimeUnit],\n    callback?: (error: Error | null, result?: StorageRecord<T>) => void,\n): Promise<void>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"key"),": The key to set for the given value (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"value"),": The value that is being stored. This can be either a value or a function that returns the given value. (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"maxAge"),": An optional maximum ttl after which the value will become stale. You can set this to either a millisecond value, or pass in an array in a more human readable format, e.g.:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.setItem('key', {}, [1, 'day'])\n")),Object(l.b)("p",null,"The first value of the array is a number representing an amount, the second value is a time-unit, with the accepted values being:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"type TimeUnit = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'\n")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"callback"),": Node style callback. ",Object(l.b)("em",{parentName:"p"},"NOTE")," the value being passed to the callback for setItem is not the raw value but rather an instance of ",Object(l.b)("inlineCode",{parentName:"p"},"StorageRecord"),"."),Object(l.b)("br",null),Object(l.b)("h2",{id:"removeitem"},Object(l.b)("inlineCode",{parentName:"h2"},"removeItem")),Object(l.b)("p",null,"Removes a value from storage."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.removeItem(\n    key: string,\n    callback?: (error: Error) => void,\n): Promise<void>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"key"),": The key of the value to remove (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"callback"),": Node style callback."),Object(l.b)("br",null),Object(l.b)("h2",{id:"mergeitem"},Object(l.b)("inlineCode",{parentName:"h2"},"mergeItem")),Object(l.b)("p",null,"Merges a stored value with the value passed in. This method uses ",Object(l.b)("inlineCode",{parentName:"p"},"Lodash Merge")," to merge values."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.mergeItem<T>(\n    key: string,\n    value: T,\n    callback?: (error: Error | null, result?: T) => void,\n): Promise<void>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"key"),": The key of the value to merge (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"value"),": The value to merge with the stored value (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"callback"),": Node style callback."),Object(l.b)("br",null),Object(l.b)("h2",{id:"multiget"},Object(l.b)("inlineCode",{parentName:"h2"},"multiGet")),Object(l.b)("p",null,"Convenience method to batch retrieve values from storage."),Object(l.b)("p",null,"The values are returned as a 3-dimensional array (array of arrays), with the first value in the array being the key and the second value being the stored value."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.multiGet(\n    keys: string[],\n): Promise<[string, any][]>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"keys"),": An array of keys of values to retrieve (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("br",null),Object(l.b)("h2",{id:"multiset"},Object(l.b)("inlineCode",{parentName:"h2"},"multiSet")),Object(l.b)("p",null,"Convenience method to batch set values in storage."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.multiSet(\n    values: {\n        key: string\n        value: any\n        maxAge?: MaxAge\n    }[],\n): Promise<void>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"values"),": An array of objects, each representing a value to be stored:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"key"),": The key to set for the given value (",Object(l.b)("strong",{parentName:"p"},"required"),")")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"value"),": The value that is being stored. This can be either a value or a function that returns the given value. (",Object(l.b)("strong",{parentName:"p"},"required"),")")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"maxAge"),": An optional maximum ttl after which the value will become stale. See the entry for ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#/setItem"}),"setItem")," for details"))),Object(l.b)("br",null),Object(l.b)("h2",{id:"multiremove"},Object(l.b)("inlineCode",{parentName:"h2"},"multiRemove")),Object(l.b)("p",null,"Convenience method to batch removes values from storage."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.multiRemove(\n    keys: string[],\n): Promise<void>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"keys"),": An array of keys of values to be removed (",Object(l.b)("strong",{parentName:"p"},"required"),")"),Object(l.b)("br",null),Object(l.b)("h2",{id:"multimerge"},Object(l.b)("inlineCode",{parentName:"h2"},"multiMerge")),Object(l.b)("p",null,"Convenience method to batch merge values."),Object(l.b)("p",null,"Returns a 3-dimensional array (array of arrays), with the first value in the array being the key and the second value being the merged result."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.multiMerge(\n    values: {\n        key: string\n        value: any\n    }[],\n): Promise<[string, any][]>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Parameters")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"values"),": An array of objects, each representing a value to be merged:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"key"),": The key of the value to be merged with (",Object(l.b)("strong",{parentName:"p"},"required"),")")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"value"),": The value to merged with the stored value. (",Object(l.b)("strong",{parentName:"p"},"required"),")"))),Object(l.b)("br",null),Object(l.b)("h2",{id:"clear"},Object(l.b)("inlineCode",{parentName:"h2"},"clear")),Object(l.b)("p",null,"Clears all keys in the given store."),Object(l.b)("p",null,"::: note only the store namespace is cleared. If you are using multiple stores, only the one on which you call ",Object(l.b)("inlineCode",{parentName:"p"},"clear")," will be affected.\n:::"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.clear(): Promise<void>\n")),Object(l.b)("br",null),Object(l.b)("h2",{id:"keys"},Object(l.b)("inlineCode",{parentName:"h2"},"keys")),Object(l.b)("p",null,"Returns all the keys in the store."),Object(l.b)("p",null,"::: note keys are retrieved only for the given store's namespace.\n:::"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Signature"),":"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-ts"}),"storage.keys(): Promise<string[]>\n")),Object(l.b)("br",null))}s.isMDXComponent=!0}}]);